package indexer

import (
	"fmt"
	"go/ast"
	"go/doc"
	"go/token"
	"log"
	"os"
	"strings"

	protocol "github.com/sourcegraph/lsif-protocol"
	"golang.org/x/tools/go/packages"
)

func (i *Indexer) indexSymbols() {
	i.visitEachPackage("Indexing symbols", i.indexSymbolsForPackage)
}

// indexSymbolsForPackage emits the LSIF data associated with textDocument/documentSymbol for a
// single Go package. See
// https://microsoft.github.io/language-server-protocol/specifications/lsif/0.5.0/specification/#documentSymbol.
//
// This data includes:
// - the textDocument/documentSymbol edge
// - the documentSymbolResult vertex, which contains a hierarchy of RangeBasedDocumentSymbol vertices
// - ranges associated with each symbol, with the appropriate range tag
//
// Because the textDocument/documentSymbol spec is document-based, all symbol hierarchies are rooted
// at documents. Top-level variables, functions, types, constants, etc. are children of the root,
// and methods are children of their receiver type.
func (i *Indexer) indexSymbolsForPackage(p *packages.Package) {
	documentSymbols := make(map[string]*symbolData)

	// Omit files (such as those generated by `go test`) that aren't in the project root because
	// those are not externally accessible.
	files := make([]*ast.File, 0, len(p.Syntax))
	for _, file := range p.Syntax {
		path := p.Fset.Position(file.Pos()).Filename
		if strings.HasPrefix(path, i.projectRoot) {
			files = append(files, file)
		}
	}

	// Protect with mutex, because multiple packages with the same package path can share files and
	// doc.NewFromFiles will modify the elements of the file slice.
	i.stripedMutex.LockKey(p.PkgPath)
	docpkg, err := doc.NewFromFiles(p.Fset, files, p.PkgPath, doc.AllDecls|doc.PreserveAST)
	if err != nil {
		i.stripedMutex.UnlockKey(p.PkgPath)
		fmt.Fprintf(os.Stderr, "Package %s aborted: doc.NewFromFiles failed with error: %s", p.PkgPath, err)
		return
	}
	i.stripedMutex.UnlockKey(p.PkgPath)

	for _, file := range files {
		filename := p.Fset.Position(file.Pos()).Filename
		if _, ok := i.documents[filename]; !ok {
			log.Printf("Skipping file symbol because file not found: %s", filename)
			continue
		}
		pos := p.Fset.Position(file.Name.Pos())
		rangeID := i.emitRangeForSymbol(pos, len(file.Name.Name), &protocol.RangeTag{
			Type: "definition",
			SymbolData: protocol.SymbolData{
				Text:   p.PkgPath,
				Detail: file.Doc.Text(),
				Kind:   protocol.Package,
				Tags:   []protocol.SymbolTag{protocol.Exported},
			},
		})
		documentSymbols[pos.Filename] = &symbolData{
			rangeID: rangeID,
		}
	}

	visitSymbol := func(pos token.Position, length int, tag *protocol.RangeTag, parent *symbolData) *symbolData {
		// emit range
		rangeID := i.emitRangeForSymbol(pos, length, tag)

		// update symbol hierarchy
		symbol := &symbolData{rangeID: rangeID}
		if parent != nil {
			parent.children = append(parent.children, symbol)
		} else if pkgSymbol, ok := documentSymbols[pos.Filename]; ok {
			pkgSymbol.children = append(pkgSymbol.children, symbol)
		}
		return symbol
	}

	for _, c := range docpkg.Consts {
		visitSymbol(p.Fset.Position(c.Decl.Pos()), len(c.Decl.Tok.String()), &protocol.RangeTag{
			Type: "definition",
			SymbolData: protocol.SymbolData{
				Text: c.Decl.Tok.String(),
				Kind: protocol.Constant,
			},
		}, nil)
	}

	for _, f := range docpkg.Funcs {
		visitSymbol(p.Fset.Position(f.Decl.Name.Pos()), len(f.Decl.Name.String()), &protocol.RangeTag{
			Type: "definition",
			SymbolData: protocol.SymbolData{
				Text: f.Decl.Name.String(),
				Kind: protocol.Function,
			},
		}, nil)
	}

	for _, t := range docpkg.Types {
		var kind protocol.SymbolKind
		for _, spec := range t.Decl.Specs {
			typeSpec := spec.(*ast.TypeSpec)
			if typeSpec.Name.Name == t.Name {
				switch typeSpec.Type.(type) {
				case *ast.StructType:
					kind = protocol.Struct
				case *ast.InterfaceType:
					kind = protocol.Interface
				default:
					kind = protocol.Class
				}

				break
			}
		}
		typeSymbol := visitSymbol(p.Fset.Position(t.Decl.TokPos+5), len(t.Name), &protocol.RangeTag{
			Type: "definition",
			SymbolData: protocol.SymbolData{
				Text: t.Name,
				Kind: kind,
			},
		}, nil)
		for _, m := range t.Methods {
			visitSymbol(p.Fset.Position(m.Decl.Name.NamePos), len(m.Name), &protocol.RangeTag{
				Type: "definition",
				SymbolData: protocol.SymbolData{
					Text: m.Name,
					Kind: protocol.Method,
				},
			}, typeSymbol)
		}
	}

	for _, v := range docpkg.Vars {
		for i, spec := range v.Decl.Specs {
			visitSymbol(p.Fset.Position(spec.Pos()), len(v.Names[i]), &protocol.RangeTag{
				Type: "definition",
				SymbolData: protocol.SymbolData{
					Text: v.Names[i],
					Kind: protocol.Variable,
				},
			}, nil)
		}
	}

	// Index result vertices and edges
	for filename, symbolData := range documentSymbols {
		doc := i.documents[filename]
		if doc == nil {
			log.Printf("Error: document not found, skipping (filename: %s)", filename)
			continue
		}
		if symbolData == nil {
			continue
		}
		results := []*protocol.RangeBasedDocumentSymbol{symbolDataToRangeBasedDocumentSymbol(symbolData)}
		resultID := i.emitter.EmitDocumentSymbolResult(results)
		i.emitter.EmitDocumentSymbolEdge(resultID, doc.DocumentID)
	}
}

type symbolData struct {
	rangeID  uint64
	children []*symbolData
}

func symbolDataToRangeBasedDocumentSymbol(data *symbolData) *protocol.RangeBasedDocumentSymbol {
	var children []*protocol.RangeBasedDocumentSymbol
	if len(data.children) > 0 {
		children = make([]*protocol.RangeBasedDocumentSymbol, len(data.children))
		for i, child := range data.children {
			children[i] = symbolDataToRangeBasedDocumentSymbol(child)
		}
	}
	return &protocol.RangeBasedDocumentSymbol{
		ID:       data.rangeID,
		Children: children,
	}
}

type rangeData struct {
	Start protocol.Pos
	End   protocol.Pos
}
